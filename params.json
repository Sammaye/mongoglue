{"tagline":"Another MongoDB ORM","google":"","body":"# Mongoglue ORM\r\n\r\nThis is a very simple ORM designed for MongoDB.\r\n\r\nIt is very much designed as a kind of [Fisher-Price](http://www.fisher-price.com/en_US/products/55197) \"My First Active Record\". Irrespective of that fact this ORM has\r\nbeen extensively tested in a live environment (as part of another project) and has been found to be quite fitting to most security needs.\r\n\r\nA lot of the documentation and examples can be found within the `tests` folder where PHPUnit tests are performed on each section of the ORM. The file `document.php`\r\nand the models in `tests/documents` would be of particular interest to new users.\r\n\r\n## The Why of Fry?\r\n\r\nI built this as a personal project to understand how other frameworks do Active Record. This ORM in fact comes from a MVC framework I built myself to learn how frameworks such as Yii,\r\nLithium and CakePHP (etc) actually work.\r\n\r\nWhen I decided to incorporate this as a separate module from that previous project the intention I had in mind was to create an Active Record model slimmer and more transparent\r\nto the driver than Doctrine 2. I suppose you could say I designed this to sit in the middle area between the driver and Doctrine 2 in terms of usage.\r\n\r\n## The Core\r\n\r\nIt is important to note that not all the files you see in this repository are actually needed.\r\n\r\nMost of the files contained in here are actually helpers or add-ons for the main core of the ORM.\r\n\r\nThe core only really consists of:\r\n\r\n\t/mongoglue/Server.php\r\n\t/mongoglue/Database.php\r\n\t/mongoglue/Cursor.php\r\n\t/mongoglue/Document.php\r\n\t/mongoglue/validators/Base.php\r\n\r\nIf you intend to use behaviours and/or validators it might be good to keep:\r\n\r\n\t/mongoglue/Validator.php\r\n\t/mongoglue/Behaviour.php\r\n\r\nAnd their respective folders as `behaviours` and `validators`. The files listed above act as parent classes that your own behaviours etc can inherit and if you end up\r\ndownloading a behaviour and/or validator from other individuals they might require these classes.\r\n\r\nEverything else on top is either helpers or just there to make your life a little easier.\r\n\r\n## Using it\r\n\r\nAs I said, I have designed this to be quite transparent to the driver itself so lets get an example out:\r\n\r\n\trequire 'mongoglue/Server.php';\r\n\r\n  \t$mongo = new mongoglue\\Server(new MongoClient(), array(\r\n\t    'documentDir' => dirname(__FILE__).'/mongoglue/tests/documents',\r\n\t    'documentns' => '\\\\mongoglue\\\\tests\\\\documents'\r\n  \t));\r\n  \t$db = $mongo->mydb;\r\n  \t$test = $db->select('test');\r\n\r\nYou will see that the first file I include is the `Server` class within the `mongoglue` root. Once this file is there I can make a new instance of it passing a connection object\r\n(`new Mongo()` and `new MongoClient()` both shown here) with some parameters. I should note that even though the `documentDir` is needed the `documentns` is not unless you have\r\nnamespaced you models, then it is.\r\n\r\nThe `documentDir` should go from the root `/` or `C:\\` (or whatever drive letter you are on) depending on the OS you are on. As an example, instead of passing `app/documents` as my\r\n`documentDir` I would actually pass `/srv/workspace/mydomain.co.uk/htdocs/documents`.\r\n\r\nOnce you have your server class you can then use it like you would the native MongoDB driver. Accessing a `__get` on the `Server` class will get a database and accessing a `__get`\r\non the returned `Database` class will get a RAW MongoDB collection (straight from the driver, no active record). In order to use Active Record you can either, as I show above,\r\nuse the `select($myModelName)` function within the `Database` class or you can use the `__call` to get the model, i.e. `$testCursor = $db->User()->find()`.\r\n\r\nWhen you use the `select` or `__call` abilities within the `Database` class both functions will return an instance of `\\mongoglue\\Document` which represents the document itself.\r\n\r\n## The Server\r\n\r\nThe server class is merely a wrapper for the whole ORM, it includes certain functions that woluld be best persisted across the models.\r\n\r\nSome of the stuff it persists is virtual and document field caches to stop the models from having to do reflection each time they are spun up limiting the amount of resources spent\r\non the intensive task.\r\n\r\nThe server does have one other function too. As you have notice you shoved a connection object (whether it be `Mongo()` or `MongoClient()`) into the first parameter of the server\r\nconstruct. This is because the server class also allows for pooling of multiple connections to multiple areas of your environment.\r\n\r\nIt provides helper functions for switching between connections and changing how models will save their data.\r\n\r\nTo provide an example of connection switching in mongoglue here is a snippet:\r\n\r\n\t$mongo = new mongoglue\\Server(new Mongo(), array(\r\n\t\t'documentDir' => dirname(__FILE__).'/mongoglue/tests/documents',\r\n\t\t'documentns' => '\\\\mongoglue\\\\tests\\\\documents'\r\n\t));\r\n\r\n\t// Lists all connections stored in the class\r\n\t$mongo->getConnectionList();\r\n\r\n\t// We add a connection, but the connection is not active here\r\n\t$mongo->addConnection('myBlogConnection', new MongoClient());\r\n\r\n\t// Now we set the connection\r\n\t$mongo->setConnection('myBlogConnection');\r\n\r\n\t// Now we remove that connection\r\n\t$mongo->removeConnection('myBlogConnection');\r\n\r\n\t// Now we reset the connection to default\r\n\t$mongo->setConnection('default');\r\n\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>the server class is referenced to all of its database and model classes which means that changing the connection on the server class has an effect on all the other classes you\r\nuse that reference that server object.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>Connections will not \"reset\" themselves after a single operation, the connection will persist as the new master connection until it is either removed or switched out.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>the connection you first put into the constructor of the server class will be labelled as the <code>default</code> connection and will persist in the connections array with such a label.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>the <code>selectCollection</code> function has been deprecated in mongoglue on the server class. Unlike the driver I have decided to go with a full deprecation of this function since it\r\nwas a blurring of roles. The server should deal with selecting databases not collections.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n## The Database\r\n\r\nThe database class is dirt simple and is merely a wrapper for `MongoDB` ( http://php.net/manual/en/class.mongodb.php ) and implements very little on top.\r\n\r\nOne of the little things it does implement on top is a remodelled `selectCollection` function which can now load and use a indexes file. The indexes will apply to both active record\r\nand non-active record actions commited through mongoglue.\r\n\r\nYou can find the `Indexes.php` file within the root of the mongoglue directory. Within it you will see some examples already placed. The format of it is basically: *An array\r\nwith keys of the names of collections with an array of arrays of index configurations*\r\n\r\nAs an example if we wanted to set two indexes on the `user` collection, one for unique email and another non-unique for username:\r\n\r\n\tarray(\r\n\t\t'user' => array(\r\n\t\t\tarray(array('email' => 1), array('unique' => true)),\r\n\t\t\tarray(array('username' => 1)),\r\n\t\t)\r\n\t)\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>the indexes files for mongoglue is very basic and only really to place a standard set of indexes on a single database. It is by no means required and if not present\r\nmongoglue will just not look for it again on that thread.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n## The Document\r\n\r\nA simple, bog basic document looks like this:\r\n\r\n\tnamespace mongoglue\\tests\\documents;\r\n\r\n  \tclass test extends \\mongoglue\\Document{\r\n\r\n    \tfunction collectionName(){\r\n      \t\treturn 'test';\r\n    \t}\r\n\r\n    \tpublic static function model($mongo, $dbname = null, $class = __CLASS__){\r\n      \t\treturn parent::model($mongo, $dbname, $class);\r\n    \t}\r\n  \t}\r\n\r\nAll documents must extend `\\mongoglue\\Document` and implement the `model` function.\r\n\r\nHere I provide a collection name and a model function. The model function, like in Yii, allows you to access the model from almost anywhere almost immediately by only supplying a\r\n`\\mongoglue\\Database` object or alternatively a `\\mongoglue\\Server` object.\r\n\r\nThere are numerous little pieces of information and detail you can add to your model to make it do exactly what you and this is what we will be covering next.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>if you use the server object you must also supply a database name in the <code>$dbname</code> parameter.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Fields and Virtual Attributes\r\n\r\nThere is no requirement to define a schema within the model.\r\n\r\nBy default every variable within the model is declared a database attribute however there are ways to define virtual attributes:\r\n\r\n\tclass test extends \\mongoglue\\Document{\r\n\r\n    \t/** @virtual */\r\n    \tpublic $lastRunEvent;\r\n\r\n  \t}\r\n\r\nUsing the `@virtual` annotation in PHP Doc blocks you can actually assign virtual attributes to your model that will not be saved but can be treated like any other document variable,\r\ni.e. they can be validated.\r\n\r\nYou can define defaults for any of your schema fields by simply adding them to your class and, in PHP, just assign a default within the class definition:\r\n\r\n\tclass test extends \\mongoglue\\Document{\r\n\r\n    \tpublic $lastRunEvent = 'None';\r\n\r\n  \t}\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>Unless you are knowledgable above this stuff it is best to stick to making all variables of the <code>public</code> scope.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Events\r\n\r\nThe document class supports a number of events that can be used by not only you but alos other addons such as behaviours:\r\n\r\nIf you return false from a `beforeX()` function, such as `beforeValidate()`, it will actually halt current processing stop further action within the model.\r\n\r\nDoing the same within a `afterX()` function will not have the same effect and further processing will continue regardless.\r\n\r\n- `afterConstruct()` is quite self explanatory really, it runs after the class constructor but before setting attributes in the model\r\n- `beforeFind()` run as the first thing before finding a document\r\n- `afterFind()` runs as the last thing after finding a document\r\n- `beforeValidate()` runs prior to validaton of the model\r\n- `afterValidate()` runs after validation of the model\r\n- `beforesave()` runs before the save of a document, whether it be insert or update (take heed of that last sentence when adding functionality there)\r\n- `aftersave()` run after the save of a document, again, whether it be an insert or an update\r\n- `beforeDelete()` runs before the deletion of the document\r\n- `afterDelete()` runs after deletion of the document\r\n\r\n### Scenarios\r\n\r\nScenarios enable different actions at different times. The scenarios can apply in both manual coding and in the validation of a model.\r\n\r\nBy default a new model will have a scenario of `insert` and a saved model will have a scenario of `update`.\r\n\r\nGetters and setters are provided for the scenarios as part of the models public API:\r\n\r\n\tfunction beforesave(){\r\n    \t$scenario = $this->getScenario();\r\n    \t$this->setScenario($scenario);\r\n  \t}\r\n\r\n### Relations\r\n\r\nRelations are vey useful if you intend to have a relational model of some kind.\r\n\r\nYou can define a set of relations via the `relations` function within the model:\r\n\r\n\tfunction relations(){\r\n    \treturn array(\r\n\t      \t'testDetail' => array('one', 'testDetail', 'test_id'),\r\n\t      \t'testDetails' => array('many', 'testDetail', 'test_id'),\r\n\t      \t'embeddedDetails' => array('many', 'testDetail', '_id', 'on' => 'test_ids'),\r\n\t      \t'conditionalDetails' => array('many', 'testDetail', 'test_id', 'where' => array(\r\n\t        \t'name' => 'Programming'\r\n\t      \t))\r\n    \t);\r\n  \t}\r\n\r\nAs seen from the examples above you can set a variety of different options on a relation however the relation can only consist of:\r\n\r\n- A type as the first array position, `one` or `many`\r\n- A model as the second array position, i.e. `User`\r\n- A foreign key in the third position. By default mongoglue will attempt to connect the `_id` of the current document to the field you specify in the child document\r\n- A `on` clause, incase the `_id` is not the foreign key\r\n- A `where` clause to limit a relation\r\n\r\nIt should be noted that the relational behaviour can support either a single `ObjectId` or a `DBRef` or an array of `OjbectId`s as the key for what information use from the parent\r\nmodel to gather the children. As example, from the above code, `test_ids` is in fact an array of `ObjectId`s that denote all the `testDetail`s that are connected to this model.\r\n\r\nThe realtions of the model can be accessed as either variables of the class (i.e. `$model->testDetail`) or using the `with()` function. The `with()` function provides the ability for you\r\nto add a relation and then later down the line specify the `where` parameter of the relation depending upon a dynamic set of variables within your application, a good example being:\r\n\r\n\t$model->with('testdetail', array('name' => $nameOfInterest));\r\n\r\nUsing `with` this way will not overwrite the cached relation at the variable position in the class, instead it will make a whole new query to the database to retrieve this information\r\nspecially for this case.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>If you provide a <code>where</code> clause within the <code>with</code> function it will in fact merge with the <code>where</code> clause \r\n\t\talready existing within the delcared relation in the model.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>Automatic Cascading is not supported by default within the ORM</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>MongoDB has no JOINs or relational integrity what-so-ever so you will need to take into account cascading etc on the application end.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Behaviours\r\n\r\nBehaviours are really useful if you want to add a common set of functions to many models. A good example of this is actually provided, as base, within this repository.\r\n\r\nThe `Timestamp.php` file in the `behaviours` folder shows a pefect example of how common functionality can exist between many models. As you can see it hooks into `beforeSave` and\r\nimplements a couple of helper functions.\r\n\r\nFor an idea of what events the behaviour can implement look to the parent class in `\\mongoglue\\Behaviour`.\r\n\r\nA model can transpose the functions within the behaviour onto itself allowing you, in this case, to call something like:\r\n\r\n\t$model->ago($model->created);\r\n\r\nTo get a user fiendly caption for how long ago the record was created.\r\n\r\nBehavours within the model sit within a function called `behaviours()` which returns an array of behaviours. As an example:\r\n\r\n\tfunction behaviours(){\r\n    \treturn array('Timestamp');\r\n  \t}\r\n\r\nA behaviour can also be passed certain information by the model to tell it how it should run. This is done within the behaviour declaration within the models `behaviours` function\r\nlike so:\r\n\r\n\tfunction behaviours(){\r\n    \treturn array('Timestamp' => array('dateFormat' => 0));\r\n  \t}\r\n\r\nThe keys within the nested array whose key is the behaviour name represent class properties.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>behaviours have no requirement to extend from <code>\\mongoglue\\Behaviour</code> provided you have the functions in your own file as well.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>A behaviours event hooks into the model will be run before your own, so the <code>Timestamp</code>s <code>beforesave()</code> \r\n\t\thook will run before your own in model one.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Setting Unsanitised Attributes\r\n\r\nIf you wish to set the attributes of the model ready for validation you can use the `_attributes()` function which will use the defined rules you either entered into the `validate()`\r\nfunction or into the `rules()` model method to judge what fields should be set within the model and which should not. As an example:\r\n\r\n\t$model->_attributes($_POST['user']);\r\n\r\nFields sent into this function that are not defined within the rules of the model (either through the `validate` or `rules` function) will be silently dropped. There will be no\r\nnotification that they have been dropped.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>Setting the attributes and validating them are two completely different things.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Validation\r\n\r\nModel validation is defined in two ways defined by calling the `validate()` function within the model. The function runs all rules defined, either adhoc within the `validate()`\r\nfunction signature or within the models `rules` function, and return a response denoting whether or not the model is valid (`true` if it is).\r\n\r\nAn example of using the models rules functions:\r\n\r\n\tfunction rules(){\r\n    \treturn array(\r\n      \t\tarray('name', 'string', 'allowEmpty' => false, 'message' => 'You must fill in a god damn name')\r\n    \t);\r\n  \t}\r\n\r\nAnd an example of using the validation adhoc within the `validate()` function:\r\n\r\n\t$valid = $user->validate($data, array(\r\n    \tarray('name', 'string', 'allowEmpty' => false, 'min' => 3, 'message' => 'You must have a username of 3 or more alpha numeric characters')\r\n  \t));\r\n\r\nThe validators do not provide their own error messaging as such you must provide a `message` parameter in the rule if you wish it to report on an error.\r\n\r\n#### Scenarios\r\n\r\nThe model rules support the model scenarios as well to ensure that only certain validation runs on certain events.\r\n\r\nA scenario based rule can be defined by defining a `on` parameter for the rule (in no particular place) with the value of the key being that of the scenario name.\r\n\r\nBy default, adding no `on` clause to the rule will in fact make the rule run on all scenarios.\r\n\r\n#### Validators\r\n\r\nIt is good to understand that mongoglue comes built in with some basic validators:\r\n\r\n- `required` makes sure a value for the field is required\r\n- `boolean` ensures a value is of type boolean\r\n- `string` ensures a value of type string\r\n- `objExist` can be used to ensure another object, defined by a condition, exists or not\r\n- `in` ensures the value is in a range of other values\r\n- `nin` ensures the values is not in a range of other values\r\n- `regex` ensures the value either complies or does not comply to the regex inserted into the rule\r\n- `compare` compares a value using specifically defined opreators (`=`,`<=`,`<`,`>`,`>=`,`!=`) whether or not the fields value compares with either a static value or a field\r\n- `number` ensures the value is a number\r\n- `url` ensures the value is a URL\r\n- `tokenized` ensures that the value is tokenized (will normally return true) but more importantly will ensure that there is not more than `x` tokenized elements in the string\r\n- `email` ensures that the value is a valid email\r\n- `safe` just denotes the field should run no validation at all and should just be passed across (not a good thing to use)\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>the email validator uses the PHP filter ( http://php.net/manual/en/filter.filters.validate.php )</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\nYou can add you own validators either in a behaviour, model or a custom validator file.\r\n\r\nAdding a validator within a behaviour or model is the same, just create a function in the class:\r\n\r\n\tfunction myval($field, $value, $params){\r\n\t\treturn true;\r\n\t}\r\n\r\nAnd then reference that within the rules:\r\n\r\n\tarray('myfield', 'myval', //Any params);\r\n\r\nWhen the validation function runs to detect if the function exists it will be able to run it and return a response.\r\n\r\nAs well as adding validators this way you can add your own class based validator (or some one elses) within the `/mongoglue/validators` folder. A basic validator setup is:\r\n\r\nnamespace mongoglue\\validators;\r\n\r\n  \tclass tester extends \\mongoglue\\Validator{\r\n    \tfunction validate($attribute, $value){\r\n\t      // The regex basically says that if the name is less than 20 alpha numeric characters but 3+ then allow it\r\n\t      // Of course you don't need a dedicated validator for this you can just use the regex validator but this is being used\r\n\t      // for unit testing\r\n\t      if(preg_match('/^[0-9a-zA-Z]{3,20}$/', $value) > 0){\r\n\t        return true;\r\n\t      }else{\r\n\t        return false;\r\n\t      }\r\n    \t}\r\n  \t}\r\n\r\nWhereby the `validate` function is the default run function whenever the validator is called which, just like the model/behaviour based validators, should return a `boolean` of success\r\nor failure.\r\n\r\nYou are not required to extend the `\\mongoglue\\Validator` class but it does provide some base functionality that the framework does use, however it is easy enough to place within your\r\nown validator.\r\n\r\nA helper `isEmpty` is provided to quickly detect if the field is provided as empty.\r\n\r\nThe owner (model) of the validator can be called by accessing the `$owner` property of the class. This provides you with full access to the parent model of the validator.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>Even though errors (providing you know what your doing) can be set from the validation functions/classes it is recommended not to</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>You must return a <code>boolean</code> of success or failure for each validator</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n#### Embedding\r\n\r\nYou can embed documents within your root document to be validated at the same time.\r\n\r\n\t$valid = $user->validate($data, array(\r\n    \tarray('embedObjects', 'embedMany', 'testEmbed'),\r\n\r\n    \tarray('address', 'embedMany', 'rules' => array(\r\n      \t\tarray('road', 'string', 'allowEmpty' => false, 'message' => 'You must enter a road name'),\r\n      \t\tarray('town', 'string', 'allowEmpty' => false, 'message' => 'You must enter a town name'),\r\n      \t\tarray('county', 'string', 'allowEmpty' => false, 'message' => 'You must enter a county name'),\r\n      \t\tarray('postal_code', 'string', 'allowEmpty' => false, 'message' => 'You must enter a post code')\r\n    \t))\r\n  \t));\r\n\r\nThe example above shows two methods of embedding: class based and pure array based.\r\n\r\nThere are two embedding type avaiable: `embedOne` and `embedMany`. The `embedOne` will just create a sub array of properties while the `embedMany` will create an array of arrays of\r\nproperties.\r\n\r\nTo embed a classed object (i.e. `testEmbed`) you simply state the type of embedding and them the class name.\r\n\r\nTo embed an array you state the embed type and then a set of rules. These rules will run separately to the root model and will act as though the root model is being validated all over\r\nagain but for this subdocument. This means that technically you can put in any rule you want, if you wished even another embed rule.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>There are no advanced control features for subdocument validation assignment like <code>$push</code> etc instead this behaviour must be done manually.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n##### Design Considerations\r\n\r\nEven though it is perfectly supported and allowed within the ORM to embed object classes and multi-level embed it is not always considered good database or application design.\r\n\r\nEmbedding many classed objects and many validation rules many levels can cause a huge recursion which can have a detrimental effect on the speed and memory usage of your application.\r\nAside from that classed subdocuments are normally an \"iffy\" area due to the fact that they normal represent separate entities (i.e. `comments` embedded into a `post`).\r\n\r\nPlease consider carefully about embedding and if in doubt either ask Stackoverflow ( http://www.stackoverflow.com ) or the `mongodb-user`\r\n( https://groups.google.com/forum/?fromgroups=#!forum/mongodb-user ) Google Group.\r\n\r\n#### Validation Errors\r\n\r\nOnce the model has been validated there might be errors.\r\n\r\nTo retrieve any errors in the model you can use `getErrors()` or `getFirstError()`.\r\n\r\nThe errors are returned as an associative array of fields with each field having a sub array of error messages:\r\n\r\n\tarray\r\n    \t'name' =>\r\n\t\t\tarray\r\n\t\t\t\t0 => string 'That username already exists please try another.' (length=48)\r\n    \t'embedObjects' =>\r\n\t\t\tarray\r\n\t\t\t\t0 =>\r\n\t\t\t\t\tarray\r\n            \t\t\t'name' =>\r\n\t\t\t\t\t\t\tarray\r\n\t\t\t\t\t\t\t...\r\n    \t'address' =>\r\n\t\t\t\tarray\r\n\t\t\t\t\t0 =>\r\n\t\t\t\t\t\tarray\r\n            \t\t\t\t'road' =>\r\n\t\t\t\t\t\t\t\tarray\r\n\t\t\t\t\t\t\t\t...\r\n            \t\t\t\t'postal_code' =>\r\n\t\t\t\t\t\t\t\tarray\r\n\t\t\t\t\t\t\t\t...\r\n\t\t\t\t\t1 =>\r\n\t\t\t\t\t\tarray\r\n            \t\t\t\t'county' =>\r\n\t\t\t\t\t\t\t\tarray\r\n\t\t\t\t\t\t\t\t...\r\n\t\t\t\t\t2 =>\r\n\t\t\t\t\t\tarray\r\n            \t\t\t\t'postal_code' =>\r\n\t\t\t\t\t\t\t\tarray\r\n\t\t\t\t\t\t\t\t...\r\n\r\nThe `embedObjects` and `address` fields represent subdocuments that have received errors. The format of these errors is depedant upon the embedding type. If it is `embedOne` it will\r\njust embed a set of fields exactly like the document however if the embedding type is `embedMany` then it will have a `0` indexed array of nested documents with their errors:\r\n\r\n\tarray\r\n\t\t0 =>\r\n\t\t\tarray\r\n\t        \t'road' =>\r\n\t\t\t\t\tarray\r\n\t\t\t\t\t\t0 => string 'You must enter a road name' (length=26)\r\n\t        \t'postal_code' =>\r\n\t\t\t\t\tarray\r\n\t\t\t\t\t\t0 => string 'You must enter a post code' (length=26)\r\n\t\t1 =>\r\n\t\t\tarray\r\n\t        \t'county' =>\r\n\t\t\t\t\tarray\r\n\t\t\t\t\t\t0 => string 'You must enter a county name' (length=28)\r\n\t\t2 =>\r\n\t\t\tarray\r\n\t        \t'postal_code' =>\r\n\t\t\t\t\tarray\r\n\t\t\t\t\t\t0 => string 'You must enter a post code' (length=26)\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>The order of the document indexing within <code>embedMany</code> subdocuments is dependant upon how to assign it. \r\n\t\tIf this comes from a <code>$_POST</code> then it will be in the same order as they are displayed in your form</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n##### getErrors()\r\n\r\nThis function returns either all errors in the model, or if a field was provided as the parameter (i.e. `$model->getErrors('name')`) will get all errors for that field.\r\n\r\n##### getFirstError()\r\n\r\nExactly the same as above except it will get the first error from the field. It will get the first global error is not field is defined.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td><code>validate</code> also returns a <code>boolean</code> on whether the model validated or not, \r\n\t\t<code>true</code> to denote it did and <code>false</code> respectively.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Setting Sanitised Attributes\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>It is NOT advised you do this from a <code>$_POST</code> or other user entered data. Please do not PASS GO, go straight to JAIL.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\nWhen you know what you have is OK to put into the document without validation you can use the `setAttributes()` function providing it\r\nwith a array of properties with the key of each element being the property name:\r\n\r\n\t$model->setAttributes(array('name' => 'sammaye'))\r\n\r\n### Getting the document\r\n\r\nThere are couple of functions to get the document back out of the model once you have placed it in. The one to use depends upon your need:\r\n\r\n- If you only need database fields (no virtual attributes) you can use either `getDocument()` or `getRawDocument()`. The difference between the two being that `getRawDocument` returns\r\nany subdocuments etc stripped of their `\\mongoglue\\Document` class whereas `getDocument()` does not.\r\n- If you need all attributes you can use `getAttributes()`. This function currently runs `getDocument()` and then merge those results with the virtual attributes to return a\r\nresult\r\n\r\nYou can get both the BSON encoded and the JSON encoded version of the raw document by using `getBSONDocument()` or alternatively `getJSONDocument()`.\r\n\r\n### Saving\r\n\r\nA document will and should always call the `save()` function, whether it be new or not. The `save()` function will automatically detect if the record should be inserted or updated\r\nand will peform the needed action. An example of using `save` is:\r\n\r\n\t$model->save();\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>By default validation is NOT set to run on everytime you call save. If you wish to run the models validation when you save you must pass `true` in as an additional parameter\r\ninto the function signature like so:\r\n<pre><code>$model->save(true);</code></pre></td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Removing a Document\r\n\r\nThe model supports a `remove()` function which by default will deleted based on the `_id` of the document:\r\n\r\n\t$model->remove();\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>Currently the <code>primaryKey</code> function has no effect on how the remove function removes a document.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n### Checking if it is a new record\r\n\r\nThere are two ways to check if the model is a new record in mongoglue, both inside the model and outside:\r\n\r\n- You can use the insert scenario using `getScenario()` to understand if it is that current scenario\r\n- The model actually provides a dedicated `isNew()` function which you can evaluate to either true or false directly.\r\n\r\n### Cleaning and Reloading\r\n\r\nOnce every so often you might need to either clean and document or reload it completely from database because of some special case whereby active record did not work so well.\r\n\r\nThe model has two functions: `clean()` and `refresh()`.\r\n\r\nThe `clean` does exactly what it says on the tin however the `refresh` will run a `clean` (will actually call the `clean` function) and then replace the documents attributes.\r\n\r\n## Finding Documents\r\n\r\nThe document class acts as way to both find and save a record using active record. There are 3 methods for finding a record on the document class:\r\n\r\n    $db->select('test')->find()\r\n\r\nIs analogous to the `find()` command in the MongoDB driver and will return a `\\mongoglue\\Cursor` of results.\r\n\r\n\t$db->select('test')->findOne()\r\n\r\nIs analogous to the `findOne()` command in the MongoDB driver and will return a `\\mongoglue\\Document` of the found document.\r\n\r\n\t$db->select('test')->findById();\r\n\r\nThis function is a special helper for `findOne`. It will take either a `MongoId` or the hexadecimal string representation of an `ObjectId` (`MongoId`) and will return the found\r\ndocument.\r\n\r\n### Searching\r\n\r\nYou can use a function within each model called `search()` to search for all documents in a full text manner using regexes.\r\n\r\nThe function has a signature of:\r\n\r\n\tsearch(an_array_of_fields_to_search, a_term, an_extra_query_piece);\r\n\r\nAnd can be exampled by:\r\n\r\n\t$model->search(array('title', 'description'), 'sammaye', array('user_id' => new MongoId()));\r\n\t\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>The search is very primative. It does not detect ranking nor relavance, merely just finds documents with those terms in the specified fields. \r\n\t\tWith MongoDB 2.4 this function will become obsolete due to the new full text search abilities, use this if you are on an older version of MongoDB.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>Please refer to the documentation page on <a href=\"http://docs.mongodb.org/manual/reference/operators/#_S_regex\">$regex</a> where by it states:\r\n\r\n<blockquote> $regex can only use an index efficiently when the regular expression has an anchor for the beginning (i.e. ^) of a string and is a case-sensitive match.\r\n Additionally, while /^a/, /^a.*/, and /^a.*$/ match equivalent strings, they have different performance characteristics. All of these expressions use an index if\r\n an appropriate index exists; however, /^a.*/, and /^a.*$/ are slower. /^a/ can stop scanning after matching the prefix.</blockquote>\r\n\r\nThis function uses index unfriendly regexes to perform its search. Please ensure you have something else which limits the query first i.e.:\r\n\r\n<pre><code>$model->search(array('title', 'description'), 'sammaye', array('user_id' => new MongoId()));</code></pre>\r\n\r\nWhereby I use the `user_id` to actually limit the query.</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n## The Cursor\r\n\r\nYou will very rarely use the cursor directly, however, it is good to know about it. Whenever you do a `find()` on an active record you will get back a `Cursor` (not a `MongoCursor`)\r\nwhich works like the `MongoCursor` but should be not be confused with it. It is an active record version of the `MongoCursor` specially built for mongoglue which, with each iteration,\r\nlazy loads the model and fills in the properties.\r\n\r\nThe cursor can be called directly, like a data provider:\r\n\r\n\tnew \\mongoglue\\Cursor(array('name' => 'sammaye'), 'test', $db);\r\n\r\nThe first parameter being an array of the query and the second being a string of the class name and the third being the `\\mongoglue\\Database` object.\r\n\r\nIt is, of course, easier to normally just call it straight from the model via `$model->find()`.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr><td>Note:</td><td>There is no eager load option on the cursor</td></tr>\r\n\t</tbody>\r\n</table>\r\n\r\n## Aggregation Framework\r\n\r\nMongoglue does not support the aggregation framework as such (aggregation and active record never goes well together) but it does have a helper with which to do aggregation on the model:\r\n\r\n\t$model->aggregate(array(//whatever))\r\n\r\nIt is basically a helper that points directly to the drivers own `aggregate` function so it works exactly the same.\r\n\r\n## Write Concern\r\n\r\nThe default write concern for mongoglue is `1` ( http://php.net/manual/en/mongo.writeconcerns.php ) with journal ack off. You can change these defaults using:\r\n\r\n\t$mongo->writeConcern = 'majority';\r\n\t$mongo->journaled = true;\r\n\r\nYou can also set the write concern per query, taking the previous example:\r\n\r\n\t$db->select('user')->setAttributes(array('name' => 'sammaye'))->save(array('w' => 'majority', 'j' => true));\r\n\r\n## Documentation notes\r\n\r\nAs I said earlier. A lot of the documentation and examples can be found in various files within the `tests` folder. The `tests` folder is designed to provide a set of standard\r\ntests with full examples of using 99% of the ORMs functionality. The file `document.php` and the models in `tests/documents` would be of particular interest to new users.\r\n\r\n## Known Flaws\r\n\r\n- mongoglue does not support field selectivity at the moment \r\n- mongoglue does not support [covered queries](http://docs.mongodb.org/manual/applications/indexes/#create-indexes-that-support-covered-queries)\r\n- mongoglue cannot eager load relationships for models for use with in-memory sorting on the application end\r\n\r\nAnd probably more but that's what I could think of immediately. \r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Mongoglue"}